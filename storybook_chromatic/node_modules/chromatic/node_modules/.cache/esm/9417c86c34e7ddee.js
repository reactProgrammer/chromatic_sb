let fs,join,slash,URL,getDependentStoryFiles,createTask,transitionTo,uploadFiles,deviatingOutputDir,noStatsFile,failed,initial,skipped,validating,invalid,preparing,tracing,traced,starting,success,uploading;_34e‍.x([["validateFiles",()=>validateFiles],["traceChangedFiles",()=>traceChangedFiles],["uploadStorybook",()=>uploadStorybook],["default",()=>_34e‍.o]]);_34e‍.w("fs-extra",[["default",["fs"],function(v){fs=v}]]);_34e‍.w("path",[["join",["join"],function(v){join=v}]]);_34e‍.w("slash",[["default",["slash"],function(v){slash=v}]]);_34e‍.w("url",[["URL",["URL"],function(v){URL=v}]]);_34e‍.w("../lib/getDependentStoryFiles",[["getDependentStoryFiles",["getDependentStoryFiles"],function(v){getDependentStoryFiles=v}]]);_34e‍.w("../lib/tasks",[["createTask",["createTask"],function(v){createTask=v}],["transitionTo",["transitionTo"],function(v){transitionTo=v}]]);_34e‍.w("../lib/uploadFiles",[["default",["uploadFiles"],function(v){uploadFiles=v}]]);_34e‍.w("../ui/messages/warnings/deviatingOutputDir",[["default",["deviatingOutputDir"],function(v){deviatingOutputDir=v}]]);_34e‍.w("../ui/messages/warnings/noStatsFile",[["default",["noStatsFile"],function(v){noStatsFile=v}]]);_34e‍.w("../ui/tasks/upload",[["failed",["failed"],function(v){failed=v}],["initial",["initial"],function(v){initial=v}],["skipped",["skipped"],function(v){skipped=v}],["validating",["validating"],function(v){validating=v}],["invalid",["invalid"],function(v){invalid=v}],["preparing",["preparing"],function(v){preparing=v}],["tracing",["tracing"],function(v){tracing=v}],["traced",["traced"],function(v){traced=v}],["starting",["starting"],function(v){starting=v}],["success",["success"],function(v){success=v}],["uploading",["uploading"],function(v){uploading=v}]]);/* eslint-disable no-param-reassign */
























const TesterGetUploadUrlsMutation = `
  mutation TesterGetUploadUrlsMutation($paths: [String!]!) {
    getUploadUrls(paths: $paths) {
      domain
      urls {
        path
        url
        contentType
      }
    }
  }
`;

// Get all paths in rootDir, starting at dirname.
// We don't want the paths to include rootDir -- so if rootDir = storybook-static,
// paths will be like iframe.html rather than storybook-static/iframe.html
function getPathsInDir(ctx, rootDir, dirname = '.') {
  try {
    return fs
      .readdirSync(join(rootDir, dirname))
      .map((p) => join(dirname, p))
      .map((pathname) => {
        const stats = fs.statSync(join(rootDir, pathname));
        if (stats.isDirectory()) {
          return getPathsInDir(ctx, rootDir, pathname);
        }
        return [{ pathname, contentLength: stats.size }];
      })
      .reduce((a, b) => [...a, ...b], []); // flatten
  } catch (e) {
    ctx.log.debug(e);
    throw new Error(invalid({ sourceDir: rootDir }, e).output);
  }
}

function getOutputDir(buildLog) {
  const outputString = 'Output directory: ';
  const outputIndex = buildLog.lastIndexOf(outputString);
  if (outputIndex === -1) return undefined;
  const remainingLog = buildLog.substr(outputIndex + outputString.length);
  const newlineIndex = remainingLog.indexOf('\n');
  const outputDir = newlineIndex === -1 ? remainingLog : remainingLog.substr(0, newlineIndex);
  return outputDir.trim();
}

function getFileInfo(ctx, sourceDir) {
  const lengths = getPathsInDir(ctx, sourceDir).map((o) => ({ ...o, knownAs: slash(o.pathname) }));
  const total = lengths.map(({ contentLength }) => contentLength).reduce((a, b) => a + b, 0);
  const paths = [];
  let statsPath;
  // eslint-disable-next-line no-restricted-syntax
  for (const { knownAs } of lengths) {
    if (knownAs.endsWith('preview-stats.json')) statsPath = knownAs;
    else if (!knownAs.endsWith('manager-stats.json')) paths.push(knownAs);
  }
  return { lengths, paths, statsPath, total };
}

const isValidStorybook = ({ paths, total }) =>
  total > 0 && paths.includes('iframe.html') && paths.includes('index.html');

       const validateFiles = async (ctx, task) => {
  ctx.fileInfo = getFileInfo(ctx, ctx.sourceDir);

  if (!isValidStorybook(ctx.fileInfo) && ctx.buildLogFile) {
    try {
      const buildLog = fs.readFileSync(ctx.buildLogFile, 'utf8');
      const outputDir = getOutputDir(buildLog);
      if (outputDir && outputDir !== ctx.sourceDir) {
        ctx.log.warn(deviatingOutputDir(ctx, outputDir));
        ctx.sourceDir = outputDir;
        ctx.fileInfo = getFileInfo(ctx, ctx.sourceDir);
      }
    } catch (e) {
      ctx.log.debug(e);
    }
  }

  if (!isValidStorybook(ctx.fileInfo)) {
    throw new Error(invalid(ctx).output);
  }
};

       const traceChangedFiles = async (ctx, task) => {
  if (!ctx.git.changedFiles) return;
  if (!ctx.fileInfo.statsPath) {
    ctx.log.warn(noStatsFile());
    return;
  }

  transitionTo(tracing)(ctx, task);

  const statsPath = join(ctx.sourceDir, ctx.fileInfo.statsPath);
  const { changedFiles } = ctx.git;
  try {
    const stats = await fs.readJson(statsPath);
    ctx.onlyStoryFiles = getDependentStoryFiles(ctx, stats, changedFiles);
    ctx.log.debug(
      `Found affected story files:\n${Object.entries(ctx.onlyStoryFiles)
        .map(([id, f]) => `  ${f} [${id}]`)
        .join('\n')}`
    );
    transitionTo(traced)(ctx, task);
  } catch (e) {
    ctx.log.warn('Failed to retrieve dependent story files', { statsPath, changedFiles });
  }
};

       const uploadStorybook = async (ctx, task) => {
  if (ctx.skip) return;
  transitionTo(preparing)(ctx, task);

  const { lengths, paths, total } = ctx.fileInfo;
  const { getUploadUrls } = await ctx.client.runQuery(TesterGetUploadUrlsMutation, { paths });
  const { domain, urls } = getUploadUrls;
  const files = urls.map(({ path, url, contentType }) => ({
    path: join(ctx.sourceDir, path),
    url,
    contentType,
    contentLength: lengths.find(({ knownAs }) => knownAs === path).contentLength,
  }));

  task.output = starting(ctx).output;

  try {
    await uploadFiles(ctx, files, (progress) => {
      if (ctx.options.interactive) {
        const percentage = Math.round((progress / total) * 100);
        task.output = uploading({ percentage }).output;
      }
    });
  } catch (e) {
    if (files.find(({ path }) => path === e.message)) {
      throw new Error(failed({ path: e.message }).output);
    }
    throw e;
  }

  ctx.uploadedBytes = total;
  ctx.isolatorUrl = new URL('/iframe.html', domain).toString();
  transitionTo(success, true)(ctx, task);
};

_34e‍.d(createTask({
  title: initial.title,
  skip: (ctx) => {
    if (ctx.skip) return true;
    if (ctx.options.storybookUrl) return skipped(ctx).output;
    return false;
  },
  steps: [transitionTo(validating), validateFiles, traceChangedFiles, uploadStorybook],
}));
